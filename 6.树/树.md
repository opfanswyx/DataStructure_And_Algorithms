# 树的相关概念
>结点 根 子树 孩子结点(子节点) 双亲结点(父结点) 兄弟结点

度：一个结点拥有子树的数目称为结点的度。

路径的长度：是路线上所经过的边(链接2个结点的线段)的数目，等于结点个数减1。

**左孩子右兄弟表示法(可以将多叉树转换成二叉树)：**

指由左边孩子结点来接管父节点其余的孩子结点。类似于中国的“长兄如父”的思想。

# 二叉树
## 二叉树的分类
非完全二叉树(普通二叉树)

完全二叉树：除最后一层外，每一层上的节点数均达到最大值，最最后一层上只缺少右边的结点(每一层都优先填左边)
>叶子结点只能出现在最下两层，叶子结点集中在左边位置，同样结点的二叉树，完全二叉树深度最小

满二叉树：除叶子结点外，每个结点都有两个孩子结点，每一层的结点数都达到最大。
>深度为k的二叉树有2^k-1个结点，则是满二叉树

只有左孩子或右孩子树叫斜树，左斜树，右斜树。

## 二叉树的性质
* 性质1：在二叉树的第i层上最多有2^(i-1)个结点。

* 性质2：深度为k的二叉树至多有2^k-1个结点(k>0)。

* 性质3：对于任何一颗二叉树，当度为2的结点数有n个，则叶子数必定为n+1个。

* 性质4：具有n个结点的完全二叉树，它的深度必为log2n+1。

    2^(k-1)-1<n<=2^k-1

    k-1<=log2n<k

    k=log2n+1
* 性质5：当对完全二叉树中的结点从上至下，从左至右编号，则编号为i的结点，期左孩子编号为2i,右孩子编号为2i+1,其双亲编号为i/2(向下取整,i=1除外)

## 二叉树的链式存储结构
### 二叉链表法
结点的数据类型：
```c
typedef struct BitNode
{
    DataType data;
    struct BitNode *lchild, *rchild;
}BitNode;
typedef struct BitNode* BiTree;
```
n个结点的二叉链表中有2n个指针域，其中只有n-1个指示左右孩子，其余n+1个指针域为空。

### 三叉链表法
结点的数据类型：
```c
typedef struct BitNode
{
    DataType data;
    struct BitNode *lchild, *rchild;
    struct BitNode *parent;
}BitNode, *BiTree;
```

### 双亲表示法
```c
typedef struct BPTNode
{
    DataType data;
    int parentPosition;
    char LRTag;
}BPTNode;
```
```c
typedef struct BPTree
{
    BPTNode nodes[100];
    int num_node;
    int root;
}BPTree;
```

# 线索二叉树
线索二叉树结点结构:
```c
typedef struct BiThrNode
{
    char data;
    struct BiThrNode *lchild, *rchild;
    int LTag;       //左右标志，=0表示指向左孩子，=1指向其前驱结点
    int RTag;       //=1指向其后继结点
}BiThrNode,*BiThrTree;
```
二叉树线索化：按次序便利二叉树，在遍历过程中用线索取代空指针。
分为：先序线索化，中序线索化，后序线索化。

# 赫夫曼树
## 相关术语
* 路径
* 树的路径长度

    从树根到树中每个结点的路径长度之和
* 树的带权路径长度

    WPL=\sum_{i=1}^{n} w_{i}l_{i}

    其中，n表示叶子结点的数目；w_{i}和l_{i} 分别表示结点ki的数值和根到结点ki之间的路径长度。

## 赫夫曼编码
赫夫曼树主要用于远距离通信时的信息编码。是一种不定长编码。
赫夫曼编码的算法需要三步实现：
* 对于需要编码的字符进行扫描，统计每个字符串出现的频次，得到一个整数数组。
* 根据这个频次数组构造一颗赫夫曼树。
* 再次扫描待编码的字符，对每个字符，在赫夫曼树里搜索该字符，得到它的编码。
* 发送方与接收方需要同一套赫夫曼编码

